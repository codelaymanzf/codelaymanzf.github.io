(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{429:function(v,_,t){v.exports=t.p+"assets/img/render_pipeline.37b85b04.png"},430:function(v,_,t){v.exports=t.p+"assets/img/GPU_raster.09153f59.png"},446:function(v,_,t){"use strict";t.r(_);var r=t(53),s=Object(r.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h1",{attrs:{id:"渲染流水线"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染流水线"}},[v._v("#")]),v._v(" 渲染流水线")]),v._v(" "),r("blockquote",[r("p",[v._v("由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分成很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素，这样的处理流程叫做"),r("strong",[v._v("渲染流水线")])])]),v._v(" "),r("blockquote",[r("p",[v._v("构建 DOM 树 >> 样式计算 >> 布局阶段 >> 分层 >> 绘制 >> 分块 >> 光栅化 >> 合成")])]),v._v(" "),r("p",[r("img",{attrs:{src:t(429),alt:"渲染流水线示意图"}})]),v._v(" "),r("h2",{attrs:{id:"构建-dom-树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构建-dom-树"}},[v._v("#")]),v._v(" 构建 DOM 树")]),v._v(" "),r("p",[r("strong",[v._v("为什么要构建 DOM 树？")])]),v._v(" "),r("p",[v._v("因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换成浏览器能够理解的内容——DOM 树")]),v._v(" "),r("p",[r("strong",[v._v("DOM 构建树过程")])]),v._v(" "),r("p",[v._v("输入 HMTL >> HTML 解析器解析 >> 输出 DOM 树")]),v._v(" "),r("p",[r("strong",[v._v("HTML 和 DOM 的区别")])]),v._v(" "),r("p",[v._v("DOM 和 HTML 内容几乎是一样的，但是 HTML 不同的是，DOM 是保存在内存中的，可以通过 Javascript 来查询或修改其内容")]),v._v(" "),r("h2",{attrs:{id:"样式计算"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#样式计算"}},[v._v("#")]),v._v(" 样式计算")]),v._v(" "),r("ul",[r("li",[v._v("将 CSS 转换为浏览器能够理解的结构"),r("code",[v._v("styleSheets")])]),v._v(" "),r("li",[v._v("转换样式表中的属性值，使其标准化\n"),r("blockquote",[r("p",[v._v("2em 解析成 32px, red 解析成 rgb(255, 0, 0), bold 解析成 700 等等")])])]),v._v(" "),r("li",[v._v("计算出 DOM 树中每个节点的具体样式\n"),r("ul",[r("li",[v._v("CSS 的继承规则")]),v._v(" "),r("li",[v._v("CSS 的层叠规则")])])])]),v._v(" "),r("h2",{attrs:{id:"布局阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#布局阶段"}},[v._v("#")]),v._v(" 布局阶段")]),v._v(" "),r("blockquote",[r("p",[v._v("计算出 DOM 树中可见元素的几何位置,这个计算过程叫做布局")])]),v._v(" "),r("ul",[r("li",[v._v("创建布局树")]),v._v(" "),r("li",[v._v("布局计算")])]),v._v(" "),r("h2",{attrs:{id:"分层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分层"}},[v._v("#")]),v._v(" 分层")]),v._v(" "),r("p",[v._v("通常情况下，"),r("strong",[v._v("并不是布局树中的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层")]),v._v("。最终每个节点都会直接或间接地从属于一个层。")]),v._v(" "),r("p",[v._v("为特定的节点创建新的层的条件是？")]),v._v(" "),r("ul",[r("li",[r("strong",[r("em",[v._v("拥有层叠上下文属性的元素会被提升为单独的一层")])]),v._v(" "),r("blockquote",[r("p",[v._v("比如 "),r("code",[v._v("position: fixed")]),v._v(" "),r("code",[v._v("z-index: 2")]),v._v(" "),r("code",[v._v("filter: blur(5px)")]),v._v(" "),r("code",[v._v("opacity: .5")]),v._v(" "),r("br"),v._v("\n明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有"),r("code",[v._v("层叠上下文属性")])])])]),v._v(" "),r("li",[r("strong",[r("em",[v._v("需要裁剪(clip)的地方也会被创建为图层")])]),v._v(" "),r("blockquote",[r("p",[v._v("比如超出限定宽高的文字内容")])])])]),v._v(" "),r("h2",{attrs:{id:"图层绘制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图层绘制"}},[v._v("#")]),v._v(" 图层绘制")]),v._v(" "),r("ul",[r("li",[v._v("将图层的绘制拆分成很多小的"),r("strong",[v._v("绘制指令")])]),v._v(" "),r("li",[v._v("然后把这些指令按照顺序组成一个"),r("strong",[v._v("待绘制列表")])])]),v._v(" "),r("h2",{attrs:{id:"栅格化（raster-操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栅格化（raster-操作"}},[v._v("#")]),v._v(" 栅格化（raster)操作")]),v._v(" "),r("p",[v._v("当图层的绘制列表准备好之后，主线程会把该绘制列表"),r("strong",[v._v("提交")]),v._v("给合成线程")]),v._v(" "),r("ul",[r("li",[v._v("合成线程将图层划分为图块")]),v._v(" "),r("li",[v._v("合成线程按照视口附近的图块来优先生成"),r("strong",[v._v("位图")]),v._v(" "),r("img",{attrs:{src:t(430),alt:"GPU栅格化"}})])]),v._v(" "),r("h2",{attrs:{id:"合成和显示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合成和显示"}},[v._v("#")]),v._v(" 合成和显示")]),v._v(" "),r("p",[v._v("一旦所有图层都被栅格化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。")]),v._v(" "),r("p",[v._v("浏览器进程里有一个叫 viz 的组件, 用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。")]),v._v(" "),r("h3",{attrs:{id:"一个完整的渲染流程大致可以总结如下："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一个完整的渲染流程大致可以总结如下："}},[v._v("#")]),v._v(" 一个完整的渲染流程大致可以总结如下：")]),v._v(" "),r("ol",[r("li",[v._v("渲染进程将 HTML 内容转换为能够读懂的"),r("strong",[v._v("DOM 树")]),v._v("结构")]),v._v(" "),r("li",[v._v("渲染引擎将 CSS 样式表转换为浏览器可以理解的"),r("strong",[v._v("styleSheets")]),v._v("，计算出 DOM 节点的样式")]),v._v(" "),r("li",[v._v("创建"),r("strong",[v._v("布局树")]),v._v("，并计算元素的布局信息")]),v._v(" "),r("li",[v._v("对布局树进行分层，并生成"),r("strong",[v._v("分层树")])]),v._v(" "),r("li",[v._v("为每个图层生成"),r("strong",[v._v("绘制列表")]),v._v(", 并将其提交到合成线程")]),v._v(" "),r("li",[v._v("合成线程将图层分成"),r("strong",[v._v("图块")]),v._v("， 并在"),r("strong",[v._v("光栅化线程池")]),v._v("中将图块转换成"),r("strong",[v._v("位图")])]),v._v(" "),r("li",[v._v("合成线程发送绘制图块命令"),r("strong",[v._v("DrawQuad")]),v._v("给浏览器进程")]),v._v(" "),r("li",[v._v("浏览器进程根据 DrawQuad 消息"),r("strong",[v._v("生成页面")]),v._v("，并"),r("strong",[v._v("显示")]),v._v("到显示器上")])])])}),[],!1,null,null,null);_.default=s.exports}}]);