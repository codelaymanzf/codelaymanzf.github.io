(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{424:function(t,v,_){t.exports=_.p+"assets/img/V8_heap_space.d2c26a38.png"},425:function(t,v,_){t.exports=_.p+"assets/img/all_stop.73fb4bde.png"},426:function(t,v,_){t.exports=_.p+"assets/img/incremental_mark.75437e33.png"},451:function(t,v,_){"use strict";_.r(v);var a=_(53),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),a("blockquote",[a("p",[t._v("以 "),a("code",[t._v("Chrome")]),t._v("的 Javascript 引擎 "),a("code",[t._v("V8")]),t._v("为例来分析")])]),t._v(" "),a("h3",{attrs:{id:"代际假说-the-generational-hypothesies"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代际假说-the-generational-hypothesies"}},[t._v("#")]),t._v(" 代际假说 (The Generational Hypothesies)")]),t._v(" "),a("blockquote",[a("p",[t._v("垃圾回收的策略是建立在 "),a("code",[t._v("代际假说")]),t._v("基础之上的")])]),t._v(" "),a("ul",[a("li",[t._v("第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；")]),t._v(" "),a("li",[t._v("第二个是不死的对象，会活得更久")])]),t._v(" "),a("h3",{attrs:{id:"新生代和老生代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新生代和老生代"}},[t._v("#")]),t._v(" 新生代和老生代")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("V8")]),t._v("把堆分为"),a("code",[t._v("新生代")]),t._v("和"),a("code",[t._v("老生代")]),t._v("两个区域，新生代存放的是生存时间短的对象，老生代存入生存时间久的对象")])]),t._v(" "),a("blockquote",[a("p",[t._v("新生代通常只支持 1~8M 的容量，而老生区支持的容量就大很多了")])]),t._v(" "),a("h3",{attrs:{id:"副垃圾回收器和主垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器和主垃圾回收器"}},[t._v("#")]),t._v(" 副垃圾回收器和主垃圾回收器")]),t._v(" "),a("ul",[a("li",[t._v("副垃圾回收器，主要负责新生代的垃圾回收")]),t._v(" "),a("li",[t._v("主垃圾回收器，主要负责老生代的垃圾回收")])]),t._v(" "),a("h3",{attrs:{id:"垃圾回收器的工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器的工作流程"}},[t._v("#")]),t._v(" 垃圾回收器的工作流程")]),t._v(" "),a("ul",[a("li",[t._v("第一步是"),a("code",[t._v("标记")]),t._v("空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，所谓非活动对象就是可以进行垃圾回收的对象")]),t._v(" "),a("li",[t._v("第二步"),a("code",[t._v("回收")]),t._v("非活动对象所占据的内存。其实就是在所有标记完成后，统一清理内存中所有被标记为可回收的对象")]),t._v(" "),a("li",[t._v("第三步是做内存"),a("code",[t._v("整理")]),t._v("。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为"),a("code",[t._v("内存碎片")]),t._v("，当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如副垃圾回收器。")])]),t._v(" "),a("br"),t._v(" "),a("p",[a("img",{attrs:{src:_(424),alt:"V8堆空间"}})]),t._v(" "),a("h3",{attrs:{id:"副垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[t._v("#")]),t._v(" 副垃圾回收器")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Scavenge 算法")]),t._v(", 把新生代空间对半划分为两个区域，一个是对象区域，一个是空闲区域")])]),t._v(" "),a("blockquote",[a("p",[t._v("因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了"),a("code",[t._v("对象晋升策略")]),t._v("，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。")])]),t._v(" "),a("h3",{attrs:{id:"主垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[t._v("#")]),t._v(" 主垃圾回收器")]),t._v(" "),a("p",[t._v("主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("标记-清除(Mark-Sweep)算法")])]),t._v(" "),a("ul",[a("li",[t._v("首先是"),a("strong",[t._v("标记")]),t._v("过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为"),a("strong",[t._v("活动对象")]),t._v("，没有到达的元素就可以判断为"),a("strong",[t._v("垃圾数据")])]),t._v(" "),a("li",[t._v("接下来就是垃圾的"),a("strong",[t._v("清除")]),t._v("过程")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("标记-整理(Mark-Compact)算法")])]),t._v(" "),a("ul",[a("li",[t._v("这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。")])])])]),t._v(" "),a("p",[t._v("主垃圾回收器执行一次完整的垃圾回收流程如下图所示\n"),a("img",{attrs:{src:_(425),alt:"全停顿"}})]),t._v(" "),a("p",[a("strong",[t._v("全停顿")]),t._v(": 由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。")]),t._v(" "),a("p",[a("img",{attrs:{src:_(426),alt:"增量标记"}})]),t._v(" "),a("p",[t._v("为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为"),a("strong",[t._v("增量标记（Incremental Marking）算法")]),t._v("。")])])}),[],!1,null,null,null);v.default=e.exports}}]);