(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{450:function(t,v,a){"use strict";a.r(v);var _=a(53),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器内核-渲染进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核-渲染进程"}},[t._v("#")]),t._v(" 浏览器内核 (渲染进程)")]),t._v(" "),a("h2",{attrs:{id:"gui-渲染线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gui-渲染线程"}},[t._v("#")]),t._v(" "),a("code",[t._v("GUI 渲染线程")])]),t._v(" "),a("ul",[a("li",[t._v("负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等")]),t._v(" "),a("li",[t._v("当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行")]),t._v(" "),a("li",[t._v("注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行")])]),t._v(" "),a("h2",{attrs:{id:"js-引擎线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-引擎线程"}},[t._v("#")]),t._v(" "),a("code",[t._v("JS 引擎线程")])]),t._v(" "),a("ul",[a("li",[t._v("也称为 "),a("code",[t._v("JS 内核")]),t._v("，负责处理 Javascript 脚本程序。（例如 V8 引擎）")]),t._v(" "),a("li",[t._v("JS 引擎线程负责解析 Javascript 脚本，运行代码")]),t._v(" "),a("li",[t._v("JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序")]),t._v(" "),a("li",[t._v("同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。")])]),t._v(" "),a("h2",{attrs:{id:"事件触发线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件触发线程"}},[t._v("#")]),t._v(" "),a("code",[t._v("事件触发线程")])]),t._v(" "),a("ul",[a("li",[t._v("归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）")]),t._v(" "),a("li",[t._v("当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中")]),t._v(" "),a("li",[t._v("当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理")]),t._v(" "),a("li",[t._v("注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）")])]),t._v(" "),a("h2",{attrs:{id:"定时触发器线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定时触发器线程"}},[t._v("#")]),t._v(" "),a("code",[t._v("定时触发器线程")])]),t._v(" "),a("ul",[a("li",[t._v("传说中的 setInterval 与 setTimeout 所在线程")]),t._v(" "),a("li",[t._v("浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）")]),t._v(" "),a("li",[t._v("因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）")]),t._v(" "),a("li",[t._v("注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms")])]),t._v(" "),a("h2",{attrs:{id:"异步-http-请求线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步-http-请求线程"}},[t._v("#")]),t._v(" "),a("code",[t._v("异步 Http 请求线程")])]),t._v(" "),a("ul",[a("li",[t._v("在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求")]),t._v(" "),a("li",[t._v("将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行")])])])}),[],!1,null,null,null);v.default=e.exports}}]);